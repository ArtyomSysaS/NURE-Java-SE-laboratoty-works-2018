<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0051)http://kit.znu.edu.ua/iLec/9sem/AMPS/ind/index.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<link rel="stylesheet" type="" "text="" css"="" href="./ПJ ЛР 2 Индивидуальные задания_files/mystyles.css">
<title>Индивидуальное задание</title>
</head>

<body>
<h1 align="center"><strong>Методические рекомендации<br>
  по выполнению самостоятельного (индивидуального) завдания по дисуиплине</strong><br>
  <strong>«Платформы корпоративных информационных систем»</strong><br>
</h1>
<h3 class="labtext"><em>Тема</em> <em>индивидуальной работы:</em> «Работа с коллекциями Java».</h3>
<h3>Список использованных источников: [1], [3], [5].&nbsp;</h3>
<h2>1. Теоретические сведения</h2>
<blockquote>
<h3>1.1 Общая информация</h3>
<blockquote>
<p class="labtext">Зачастую в программе работа идет не с одним объектом, а с целой группой более или менее однотипных экземпляров (например, автопарк организации). Проще всего сделать это с помощью массивов. Однако, несмотря на то, что это достаточно эффективное решение для многих случаев, оно имеет некоторые ограничения. Так, обращаться к элементу массива можно только&nbsp;по&nbsp;его номеру (индексу). Также необходимо заранее задать длину массива и больше ее не менять.</p>
<p class="labtext">Массивы существовали в&nbsp;Java&nbsp;изначально. Кроме того, было определено два класса для организации более эффективной работы с наборами объектов:&nbsp;Hashtable&nbsp;и&nbsp;Vector. В&nbsp;JDK&nbsp;1.2 набор классов, поддерживающих работу с коллекциями, был существенно расширен.</p>
<p class="labtext">Существует несколько различных типов классов-коллекций. Все они разрабатывались,&nbsp;по&nbsp;возможности, в соответствии с единой логикой и определенными интерфейсами и там, где это возможно, работа с ними унифицирована. Однако все коллекции отличаются внутренними механизмами хранения, скоростью доступа к элементам, потребляемой памятью и другими деталями. Например, в некоторых коллекциях объекты (также называемые элементами коллекций), могут быть упорядочены, в некоторых - нет. В некоторых&nbsp;типах коллекций&nbsp;допускается дублирование ссылок на&nbsp;объект, в некоторых - нет. Далее мы рассмотрим каждый из классов-коллекций.</p>
<p class="labtext">Классы, обеспечивающие манипулирование коллекциями объектов, объявлены в пакете&nbsp;<code>java.util</code>.</p>
<h4>Интерфейсы</h4>
<h4>Интерфейс Collection</h4>
<p class="labtext">Данный интерфейс является корнем всей иерархии классов-коллекций. Он определяет базовую функциональность любой коллекции - набор методов, которые позволяют добавлять, удалять, выбирать элементы коллекции. Классы, которые реализуют интерфейс&nbsp;<code>Collection</code>, могут содержать дубликаты и пустые (<code>null</code>) значения.</p>
<p class="labtext"><code>AbstractCollection</code>, как абстрактный класс, служит основой для создания конкретных классов коллекций и содержит реализацию некоторых методов, определенных в интерфейсе&nbsp;<code>Collection</code>.</p>
<h4>Интерфейс Set</h4>
<p class="labtext">Классы, которые реализуют этот интерфейс, не допускают наличия дубликатов. В коллекции этого типа разрешено наличие только одной ссылки типа&nbsp;null. Интерфейс&nbsp;Set&nbsp;расширяет интерфейс&nbsp;Collection, таким образом, любой класс, имплементирующий&nbsp;Set, реализует все методы, определенные в&nbsp;Collection. Любой объект, добавляемый в&nbsp;Set, должен реализовать метод&nbsp;equals, чтобы его можно было сравнить с другими.</p>
<p class="labtext" id="id_190" xmlns:edi="http://www.intuit.ru/2010/edi">AbstractSet, являясь абстрактным классом, представляет собой основу для реализации различных вариантов интерфейса Set.</p>
<h4>Интерфейс List </h4>
<p class="labtext">Классы, реализующие этот интерфейс, содержат упорядоченную последовательность объектов (объекты хранятся в том порядке, в котором они были добавлены). В JDK 1.2 был переделан класс&nbsp;Vector, так, что он теперь реализует интерфейс&nbsp;List. Интерфейс&nbsp;List&nbsp;расширяет интерфейс&nbsp;Collection, и любой класс, имплементирующий&nbsp;List, реализует все методы, определенные в&nbsp;Collection, и в то же время вводятся новые методы, которые позволяют добавлять и удалять элементы из списка.&nbsp;List&nbsp;также обеспечивает&nbsp;ListIterator, который позволяет перемещаться как вперед, так и назад по элементам списка.</p>
<p class="labtext">AbstractList, как абстрактный класс, представляет собой основу для реализации различных вариантов интерфейса&nbsp;List.</p>
<div align="center"><img src="./ПJ ЛР 2 Индивидуальные задания_files/1.gif" width="556" height="605"></div>
<div align="center"><strong>Рис.1.</strong>Основные типы для работы с коллекциями.</div>
<h4>Интерфейс Map</h4>
<p class="labtext">Классы, которые реализуют этот интерфейс, хранят неупорядоченный набор объектов парами ключ/значение. Каждый ключ должен быть уникальным.&nbsp;Hashtable&nbsp;после модификации в JDK 1.2 реализует интерфейс Map. Порядок следования пар ключ/значение не определен.</p>
<p class="labtext">Интерфейс Map не расширяет интерфейс&nbsp;Collection.&nbsp;AbstractMap, будучи абстрактным классом, представляет собой основу для реализации различных вариантов интерфейса&nbsp;Map.</p>
<h4>Интерфейс SortedSet</h4>
<p class="labtext">Этот интерфейс расширяет&nbsp;Set, требуя, чтобы содержимое набора было упорядочено. Такие коллекции могут содержать объекты, которые реализуют интерфейс&nbsp;Comparable, либо могут сравниваться с использованием внешнего&nbsp;Comparator.</p>
<h4>Интерфейс SortedMap</h4>
<p class="labtext">Этот интерфейс расширяет&nbsp;Map, требуя, чтобы содержимое коллекции было упорядочено по значениям ключей.</p>
<h4>Интерфейс Iterator</h4>
<p class="labtext">В Java 1 для перебора элементов коллекции использовался интерфейс&nbsp;Enumeration. В Java 2 для этих целей должны применяться объекты, которые реализуют интерфейс&nbsp;Iterator. Все классы, которые реализуют интерфейс&nbsp;Collection, должны реализовать метод&nbsp;iterator, который возвращает объект, реализующий интерфейс&nbsp;Iterator.&nbsp;Iterator&nbsp;весьма похож на&nbsp;Enumeration, с тем лишь отличием, что в нем определен метод&nbsp;remove, который позволяет удалить объект из коллекции, для которой&nbsp;Iterator&nbsp;был создан.</p>
<p class="labtext">Таким образом, подводя итог, перечислим интерфейсы, используемые при работе с коллекциями:</p>
<pre>java.util.Collection
java.util.Set
java.util.List
java.util.Map
java.util.SortedSet
java.util.SortedMap
java.util.Iterator
</pre>
<h4>Aбстрактные классы, используемые при работе с коллекциями</h4>
<p class="labtext">java.util.AbstractCollection&nbsp;- данный класс реализует все методы, определенные в интерфейсе&nbsp;Collection, за исключением&nbsp;iterator&nbsp;и&nbsp;size, так что для того, чтобы создать немодифицируемую коллекцию, нужно переопределить эти методы. Для реализации модифицируемой коллекции необходимо еще переопределить метод&nbsp;public void add(Object o)&nbsp;(в противном случае при его вызове будет возбуждено исключение&nbsp;UnsupportedOperationException&nbsp;).</p>
<div align="center"><img src="./ПJ ЛР 2 Индивидуальные задания_files/2.gif" width="523" height="608"></div>
<div align="center"><strong>Рис.2.&nbsp;</strong>Базовые абстрактные классы.</div>

<p class="labtext">Необходимо также определить два конструктора: без аргументов и с аргументом&nbsp;Collection. Первый должен создавать пустую коллекцию, второй - коллекцию на основе существующей. Данный класс расширяется классами&nbsp;AbstractList&nbsp;и&nbsp;AbstractSet.</p>
<p class="labtext">java.util.AbstractList&nbsp;- этот класс расширяет&nbsp;AbstractCollection&nbsp;и реализует интерфейс&nbsp;List. Для создания немодифицируемого списка необходимо имплементировать методы&nbsp;public Object get(int index) и public int size(). Для реализации модифицируемого списка необходимо также реализовать метод&nbsp;public void set(int index,Object element)&nbsp;(в противном случае при его вызове будет возбуждено исключение&nbsp;UnsupportedOperationException&nbsp;).</p>
<p class="labtext">В отличие от&nbsp;AbstractCollection, в этом случае нет необходимости реализовывать метод&nbsp;iterator, так как он уже реализован поверх методов доступа к элементам списка&nbsp;get, set, add, remove.</p>
<p class="labtext">java.util.AbstractSet&nbsp;- данный класс расширяет&nbsp;AbstractCollection&nbsp;и реализует основную функциональность, определенную в интерфейсе&nbsp;Set. Следует отметить, что этот класс не переопределяет функциональность, реализованную в классе&nbsp;AbstractCollection.</p>
<p class="labtext">java.util.AbstractMap&nbsp;- этот класс расширяет основную функциональность, определенную в интерфейсе&nbsp;Map. Для реализации немодифицируемого класса, унаследованного от&nbsp;AbstractMap, достаточно определить метод&nbsp;entrySet, который должен возвращать объект, приводимый к типу&nbsp;AbstractSet. Этот набор (&nbsp;Set&nbsp;) не должен обеспечивать методов для добавления и удаления элементов из набора. Для реализации модифицируемого класса&nbsp;Map&nbsp;необходимо также переопределить метод put и добавить в итератор, возвращаемый&nbsp;entrySet().iterator(), поддержку метода&nbsp;remove.</p>
<p class="labtext">java.util.AbstractSequentialList&nbsp;- этот класс расширяет&nbsp;AbstractList&nbsp;и является основой для класса LinkedList. Основное отличие от&nbsp;AbstractList&nbsp;заключается в том, что этот класс обеспечивает не только последовательный, но и произвольный доступ к элементам списка, с помощью методов&nbsp;get(int index),&nbsp;set(int index, Object element),&nbsp;add(int index, Object element)&nbsp;и&nbsp;remove(int index). Для того, чтобы реализовать данный класс, необходимо переопределить методы&nbsp;listIterator&nbsp;и&nbsp;size. Причем, если реализуется немодифицируемый список, для итератора достаточно реализовать методы&nbsp;hasNext, next, hasPrevious, previous&nbsp;и&nbsp;index. Для модифицируемого списка необходимо дополнительно реализовать метод&nbsp;set, а для списков переменной длины еще и&nbsp;add, и&nbsp;remove.</p>
</blockquote>
<h3>1.2 Сведения о коллекциях</h3>
<blockquote>
  <p class="labtext">Развернутые теоретические сведения про коллекции и их использование при программировании на языке Java можно посмотреть здесь (pdf, 947 kb, 17 стр.) <a href="http://kit.znu.edu.ua/iLec/9sem/AMPS/ind/ind_theor.pdf" target="_blank"> <img src="./ПJ ЛР 2 Индивидуальные задания_files/link_new.gif" alt="" title="Открыть методическое пособие в этом окне"></a>.</p>
</blockquote>
</blockquote>
<h2>2. Задание</h2>
<blockquote>
  <p class="labtext">Индивидуальное задание состоит из двух задач. Номер задачи выбирается согласно варианту. Номер варианта выбирается как соответствующий номер в списке журнала академической группы.  </p>
  <h3 class="labtext">Задача 1.</h3>
  <ol>
    <li class="labtext">Ввести  строки из файла, записать в список. Вывести строки в файл в обратном порядке.</li>
    <li class="labtext">Ввести  число, занести его цифры в стек. Вывести число, у которого цифры идут в  обратном порядке.</li>
    <li class="labtext">Создать в  стеке индексный массив для быстрого доступа к записям в бинарном файле.</li>
    <li class="labtext">Создать  список из элементов каталога и его подкаталогов.</li>
    <li class="labtext">Создать стек  из номеров записи. Организовать прямой доступ к элементам записи.</li>
    <li class="labtext">Занести  стихотворения одного автора в список. Провести сортировку по возрастанию длин  строк.</li>
    <li class="labtext">Задать два  стека, поменять информацию местами.</li>
    <li class="labtext">Определить  множество на основе множества целых чисел. Создать методы для определения  пересечения и объединения множеств.</li>
    <li class="labtext">Списки (стеки, очереди) I(1..n) и U(1..n) содержат результаты n-измерений тока и напряжения на неизвестном сопротивлении R. Найти приближенное число R методом наименьших квадратов.</li>
    <li class="labtext">С  использованием множества выполнить попарное суммирование произвольного  конечного ряда чисел по следующим правилам: на первом этапе суммируются попарно  рядом стоящие числа, на втором этапе суммируются результаты первого этапа и  т.д. до тех пор, пока не останется одно число.</li>
    <li class="labtext">Сложить два  многочлена заданной степени, если коэффициенты многочленов хранятся в объекте <strong>HashMap</strong>.</li>
    <li class="labtext">Умножить два  многочлена заданной степени, если коэффициенты многочленов хранятся в различных  списках.</li>
    <li class="labtext">Не используя  вспомогательных объектов, переставить отрицательные элементы данного списка в  конец, а положитель­ные – в начало этого списка.</li>
    <li class="labtext">Ввести  строки из файла, записать в список <strong>ArrayList</strong>. Выполнить  сортировку строк, используя метод <strong>sort()</strong> из класса <strong>Collections</strong>.</li>
    <li class="labtext">Задана  строка, состоящая из символов '(', ')', '[', ']', '{', '}'. Проверить  правильность расстановки скобок. Использовать стек.</li>
    <li class="labtext">Задан файл с  текстом на английском языке. Выделить все различные слова. Слова, отличающиеся  только регистром букв, считать одинаковыми. Использовать класс <strong>HashSet</strong>.</li>
    <li class="labtext">Задан файл с  текстом на английском языке. Выделить все различные слова. Для каждого слова  подсчитать частоту его встречаемости. Слова, отличающиеся регистром букв,  считать различными. Использовать класс <strong>HashMap</strong>.</li>
  </ol>
  <h3 class="labtext">Задача 2.</h3>
  <ol>
    <li>В кругу стоят N человек, пронумерованных от 1 до N. При ведении счета по кругу  вычеркивается каждый второй человек, пока не останется один. Составить две  программы, моделирующие процесс. Одна из программ должна использовать класс <strong>ArrayList</strong>, а вторая – <strong>LinkedList</strong>. Какая из двух программ работает  быстрее? Почему?</li>
    <li>Задан список целых чисел  и число X. Не используя вспомогательных  объектов и не изменяя размера списка, переставить элементы списка так, чтобы  сначала шли числа, не превосходящие X, а затем числа, большие X.</li>
    <li>Реализовать класс Graph, представляющий собой неориентированный граф. В конструкторе  класса передается количество вершин в графе. Методы должны поддерживать быстрое  добавление и удаление ребер.</li>
    <li>На базе коллекций  реализовать структуру хранения чисел с поддержкой следующих операций:
      <ul>
        <li>добавление/удаление числа;</li>
        <li>поиск числа, наиболее близкого к  заданному (т.е. модуль разницы минимален).</li>
      </ul>
    </li>
    <li>Реализовать класс,  моделирующий работу N-местной автостоянки.  Машина подъезжает к определенному месту и едет вправо, пока не встретится  свободное место. Класс должен поддерживать методы, обслуживающие приезд и  отъезд машины.</li>
    <li>Во входном файле хранятся  две разреженные матрицы А и В. Построить циклически связанные списки СА и СВ,  содержащие не­нулевые элементы соответственно матриц А и В. Просматривая  списки, вычислить: а) сумму S = A + B; б) произведение P = A * B.</li>
    <li>Во входном файле хранятся  наименования некоторых объектов. Построить список C1, элементы которого  содержат наименова­ния и шифры данных объектов, причем элементы списка должны  быть упорядочены по возрастанию шифров. Затем “сжать” список C1, удаляя дублирующие наименования объектов.</li>
    <li>Во входном файле расположены два набора положительных чисел;  между наборами стоит отрицательное число. Построить два списка C1  и С2, элементы которых содержат соответственно числа 1-го и 2-го набора таким  образом, чтобы внутри одного списка числа были упорядочены по возрастанию.  Затем объединить списки C1 и С2 в один упорядоченный список,  изменяя только значения полей ссылочного типа.</li>
    <li>Во входном файле хранится  информация о системе главных автодорог, связывающих г.Минск с другими городами  Беларуси. Используя эту информацию, постройте дерево, отображающее систему  дорог респуб­лики, а затем, продвигаясь по дереву, определить минимальный по  длине путь из г.Минска в другой заданный город. Предусмотреть возможность для  последующего сохранения дерева в виртуальной памяти.</li>
    <li>Один из способов  шифрования данных, называемый «двойным  шифрованием», заключается в том, что исходные данные при помощи  некоторого преобразования последовательно шифруются на некоторые два ключа K1 и K2. Разработать и реализовать  эффективный алгоритм, позволяющий находить ключи K1 и K2 по исходной строке и ее зашифрованному варианту. Проверить, оказался ли разработанный  способ действительно эффективным, протестировав программу для случая, когда оба  ключа К1 и К2 являются 20-битными (время ее работы не должно превосходить одной  минуты).</li>
    <li>На плоскости задано N точек. Вывести в файл описания всех прямых, которые проходят более чем  через одну точку из заданных. Для каждой прямой указать, через сколько точек  она проходит. Использовать класс <strong>HashMap</strong>.</li>
    <li>На клетчатой бумаге  нарисован круг. Вывести в файл описания всех клеток, целиком лежащих внутри  круга, в порядке возрастания расстояния от клетки до центра круга. Использовать  класс <strong>PriorityQueue</strong>.</li>
    <li>На плоскости задано N отрезков. Найти точку пересечения двх отрез­ков, имеющую минимальную  абсциссу. Использовать класс <strong>TreeMap</strong>.</li>
    <li>На клетчатом листе бумаги  закрашена часть клеток. Выделить все различные фигуры, которые образовались при  этом. Фигурой считается набор закрашенных клеток, достижимых друг из друга при  движении <br>
      в четырёх направлениях. Две фигуры являются различными, если их нельзя  совместить поворотом на угол, кратный 90 градусам, и параллельным переносом.  Используйте класс <strong>HashSet</strong>.</li>
    <li>Дана матрица из целых  чисел. Найти в ней прямоугольную подмат­рицу, состоящую из максимального  количества одинаковых элементов. Использовать класс <strong>Stack</strong>.</li>
    <li>Реализовать структуру  "черный ящик", хранящую множество чисел и имеющую внутренний счетчик K, изначально равный нулю. Структура должна поддерживать операции добавления  числа в множество и возвращение K-го по минимальности  числа из множества.</li>
    <li>На прямой гоночной трассе  стоит N автомобилей, для каждого из которых  известны начальное положение и скорость. Определить, сколько произойдет  обгонов.</li>
  </ol>
</blockquote>  
  <h2>3. Оценивание</h2>
  <blockquote>
    <p class="labtext">Каждая решенная задача может быть оценена максимально в <strong>10 баллов</strong>. Программный код, который не компилируется, и не выполняется, оценивается в 0 баллов. Баллы могут быть снижены за: неоптимальное решение задачи, несоблюдение стиля программирования, некорректные данные в отчете.</p>
    <p class="labtext">Отчет о выполнении индивидуального задания должен быть сдан не позднее понедельника зачетной недели семестра.</p>
</blockquote>
  <h2>4. Отчет</h2>
  <blockquote>
    <p class="labtext">Отчет о выполнении индивидуального задания должен содержать: титульный лист, условие аждой задачи, описание алгоритма решения задачи в общепринятых нотациях, программный код на языке Java, реализующий алгоритм решения задачи, протокол выполнения программы.</p>
</blockquote>



</body></html>